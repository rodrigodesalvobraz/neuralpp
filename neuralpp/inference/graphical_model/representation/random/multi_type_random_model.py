import math
import random
from collections import deque
from typing import Dict, Type, Callable, List, Iterable, Set

from neuralpp.inference.graphical_model.representation.factor.factor import Factor
from neuralpp.inference.graphical_model.variable.variable import Variable
from neuralpp.util import util
from neuralpp.util.util import empty


class FactorMaker:
    """
    An object that knows how to make a factor based on a tuple of variables of particular types.
    It is assumed that the first variable is always the child if the factor is to be considered
    a conditional probability.
    """

    def __init__(
        self, variable_types: List[Type], make: Callable[[List[Variable]], Factor]
    ):
        """
        Initializes a FactorMaker with a function for making a factor given its variables,
        and a tuple of the variable types (first variable is assumed to be the child if the factor
        is to be considered a conditional probability.
        """
        self.make = make
        self.variable_types = variable_types

    def __call__(self, variables: List[Variable]):
        """
        A shortcut for self.make(variables)
        """
        return self.make(variables)

    @property
    def child_type(self) -> Type:
        return self.variable_types[0]

    @property
    def parent_types(self) -> List[Type]:
        return self.variable_types[1:]

    def __str__(self):
        return f"FactorMaker for {[t.__name__ for t in self.variable_types]}"


class MultiTypeRandomModel:
    """
    A random model involving multiple customizable types of variables and factors.
    """

    # OPTIMIZATION: this may take a while when the number of variables is large (around hundreds),
    # possibly because checking the descendants becomes more and more expensive.
    # This can be avoided by keeping the descendants of each variable in memory.
    # This requires not only updating the descendants of a variable when it is used as a parent,
    # but also

    def __init__(
        self,
        threshold_number_of_variables_to_avoid_new_variables_unless_absolutely_necessary: int,
        from_type_to_number_of_seed_variables: Dict[Type, int],
        factor_makers: List[FactorMaker],
        from_type_to_variable_maker=None,
        loop_coefficient: float = 0.5,
        debug=False,
    ):
        """
        Generates a random model based on given specifications.

        The method works by generating an initial set of variables without descendants (leaves).
        Variables are generated by a "variable maker" function that makes a variable of a given type and name.
        Initially these seed variables don't have an associated distribution.

        The main loop of the method then keeping picking some variable without a distribution (the "child")
        and generates a distribution for it by using user-provided "factor makers".
        These distributions require parent variables.
        If the model still needs to grow (the threshold number of variables has not been reached yet),
        then an initial percentage of them (a user-defined "loop coefficient") will be newly-made variables,
        while the remaining ones are selected from pre-existing variables if possible.
        By "possible", we mean that the pre-existing variable can only be a parent of the child
        if it is of the right type and it is not a descendant of the child (to avoid the creation of directed cycles).
        If no pre-existing variable is allowed to be a parent of child, a new one is created.

        New variables are placed in a FIFO queue for receiving a distribution, so the graph is formed in
        a breadth-first way.

        When the target number of variables is equalled or exceeded, we
        only create new variables if absolutely necessary in order to provide a parent of the right type,
        and all new distributions created from then on are parentless.
        This causes the model generation to be completed.

        Parameters:
            threshold_number_of_variables_to_avoid_new_variables_unless_absolutely_necessary: the number of variables
            after which we only create new variables if absolutely necessary (that is, we need parents of a type
            and all available variables of that type are descendants of the child).

            from_type_to_number_of_seed_variables: a dict mapping a type to the number of required seed variables
            of that type in the model. Seed variables are the leaves of the graphical model and have no descendants.

            from_type_to_variable_maker: a dict from types to callables making a new variable of a given name (string).
            When we need to make a new variable of a given type, we use this dict. If there is no entry for the type,
            the type's constructor is used as a default.
            Default is {} (use type constructors).

            factor_makers: a list of FactorMakers to be used when adding factors to the model.

            loop_coefficient: a number from 0 to 1 reflecting how hard we should try to create loops.
            This corresponds to the probability of choosing an existing variable instead of a new variable
            to be a parent of a distribution being formed.
            Default is 0.5.

            debug: prints number of variables information as algorithm progresses.

        The generated model is available at self.from_variable_to_distribution after initialization.
        This is a dict mapping each variable to its corresponding distribution (a Factor).
        """

        # Attributes initialized by parameter
        if from_type_to_variable_maker is None:
            from_type_to_variable_maker = {}
        self.threshold_number_of_variables_to_generate = threshold_number_of_variables_to_avoid_new_variables_unless_absolutely_necessary
        self.from_type_to_number_of_seed_variables = (
            from_type_to_number_of_seed_variables
        )
        self.from_type_to_variable_maker = (
            {} if from_type_to_variable_maker is None else from_type_to_variable_maker
        )
        self.factor_makers = factor_makers
        self.loop_coefficient = loop_coefficient
        self.debug = debug

        # Attribute initialization
        self.from_variable_to_distribution: Dict[Variable, Factor] = {}
        self._queue_of_variables_without_distribution = deque()
        self._from_variable_to_descendants: Dict[Variable, Set[Variable]] = {}
        self.child_being_processed = None

        # Model generation
        self.make_seed_variables()
        self.complete_model_generation()

    def make_seed_variables(self):
        for (
            type,
            number_of_variables_of_type,
        ) in self.from_type_to_number_of_seed_variables.items():
            util.repeat(
                number_of_variables_of_type, lambda: self.make_new_variable(type)
            )

    def complete_model_generation(self):
        while not empty(self._queue_of_variables_without_distribution):
            if self.debug:
                print(
                    f"Variables generated so far: {self.number_of_variables_generated_so_far}"
                )
                print(
                    f"Variables without distributions: {len(self._queue_of_variables_without_distribution)}"
                )

            next_variable_to_get_a_distribution = (
                self.get_next_variable_without_distribution_to_process()
            )

            self.child_being_processed = next_variable_to_get_a_distribution
            self.register_distribution_for(next_variable_to_get_a_distribution)
            self.child_being_processed = None

    def get_next_variable_without_distribution_to_process(self):
        next_variable_to_get_a_distribution = (
            self._queue_of_variables_without_distribution.popleft()
        )
        return next_variable_to_get_a_distribution

    def register_distribution_for(self, variable: Variable):
        distribution = self.make_distribution_for(variable)
        self.from_variable_to_distribution[variable] = distribution

    def make_distribution_for(self, variable: Variable) -> Factor:
        if (
            self.number_of_variables_generated_so_far
            >= self.threshold_number_of_variables_to_generate
        ):
            return self.make_terminal_distribution_for(variable)
        else:
            return self.make_non_terminal_distribution_for(variable)

    def make_terminal_distribution_for(self, variable: Variable) -> Factor:
        factor_maker = self.get_factor_maker_with_no_parents_for(variable)
        factor = factor_maker.make([variable])
        return factor

    def get_factor_maker_with_no_parents_for(self, child: Variable) -> FactorMaker:
        factor_maker = self.get_factor_maker_for_child_and_condition(
            child, lambda fm: len(fm.variable_types) == 1
        )
        if factor_maker is None:
            raise RuntimeError(
                f"Cannot find maker for factor with child of type {type(child).__name__} and no parents"
            )
        return factor_maker

    def make_non_terminal_distribution_for(self, child: Variable) -> Factor:
        factor_maker = self.get_factor_maker_with_at_least_one_parent_for_child(child)
        parents = self.get_parents_for(child, factor_maker.parent_types)
        variables = [child, *parents]
        factor = factor_maker(variables)
        return factor

    def get_factor_maker_with_at_least_one_parent_for_child(
        self, child: Variable
    ) -> FactorMaker:
        factor_maker = self.get_factor_maker_for_child_and_condition(
            child, lambda fm: len(fm.variable_types) > 1
        )
        if factor_maker is None:
            raise RuntimeError(
                f"Cannot find maker for factor with child of type {type(child).__name__} "
                f"and at least one parent"
            )
        return factor_maker

    def get_factor_maker_for_child_and_condition(
        self, child: Variable, condition: Callable[[FactorMaker], bool]
    ) -> FactorMaker:
        appropriate_factor_makers = [
            fm
            for fm in self.factor_makers
            if fm.child_type == type(child) and condition(fm)
        ]
        factor_maker = (
            random.choice(appropriate_factor_makers)
            if appropriate_factor_makers
            else None
        )
        return factor_maker

    def get_parents_for(
        self, child: Variable, types_of_parents: List[Type]
    ) -> List[Variable]:
        # When obtaining parents for child, we dedicate a number of the initial ones to new variables
        # (so the model keeps growing if needed)
        # and the remaining as pre-existing ("old" for short) variables if possible (otherwise
        # we would always use new variables and never get cycles).
        # If no old variable of the right type exist, a new variable is made and used instead.

        new_variable_parents = self.get_new_variable_parents(types_of_parents)

        index_of_first_remaining_parent = len(new_variable_parents)
        types_of_remaining_parents = types_of_parents[index_of_first_remaining_parent:]
        remaining_parents = self.get_remaining_parents(
            child, types_of_remaining_parents
        )

        parents = [*new_variable_parents, *remaining_parents]
        for parent in parents:
            self.update_descendants_dict_when_parent_gets_new_child(parent, child)
        return parents

    def get_new_variable_parents(self, types_of_parents) -> List[Variable]:
        number_of_new_variable_parents = min(
            self.number_of_variables_that_still_need_to_be_generated,
            self.get_max_number_of_new_variable_parents(types_of_parents),
        )
        new_variable_parents = [
            self.make_new_variable(parent_type)
            for parent_type in types_of_parents[:number_of_new_variable_parents]
        ]
        return new_variable_parents

    def get_max_number_of_new_variable_parents(self, types_of_parents: List[Type]):
        number_of_parents = len(types_of_parents)
        max_number_of_new_variables = math.ceil(
            number_of_parents * (1 - self.loop_coefficient)
        )
        return max_number_of_new_variables

    def get_remaining_parents(
        self, child: Variable, types_for_old_variable_parents: List[Type]
    ):
        attempted_old_variable_parents = self.get_attempted_old_variable_parents(
            child, types_for_old_variable_parents
        )
        remaining_parents = [
            self.use_parent_or_make_new_one_if_none(attempted, parent_type)
            for attempted, parent_type in zip(
                attempted_old_variable_parents, types_for_old_variable_parents
            )
        ]
        return remaining_parents

    def use_parent_or_make_new_one_if_none(
        self, parent: Variable, type: Type
    ) -> Variable:
        return parent if parent is not None else self.make_new_variable(type)

    def get_attempted_old_variable_parents(
        self, child: Variable, types_for_attempted_old_variable_parents: List[Type]
    ) -> List[Variable]:
        old_variable_parent_candidates = [
            v
            for v in self.variables_generated_so_far
            if v is not child and v not in self._from_variable_to_descendants[child]
        ]
        old_variable_parent_candidates_provider = lambda: old_variable_parent_candidates

        conditions_for_old_variable_parents = [
            lambda v, parent_type=parent_type: type(v) == parent_type
            for parent_type in types_for_attempted_old_variable_parents
            # the need for the odd repetition of 'parent_type' above is that
            # otherwise the same 'parent_type' variable will be shared by all lambdas
            # and only the last value will be used.
            # However using parameter 'parent_type' means each lambda will capture a different variable and value
            # https://stackoverflow.com/questions/2295290/what-do-lambda-function-closures-capture
        ]

        attempted_old_variable_parents = util.choose_elements_without_replacement(
            old_variable_parent_candidates_provider, conditions_for_old_variable_parents
        )
        return attempted_old_variable_parents

    def update_descendants_dict_when_parent_gets_new_child(
        self, parent: Variable, child: Variable
    ):
        previous_descendants_of_parent = set(self._from_variable_to_descendants[parent])

        self._from_variable_to_descendants[parent].add(child)
        self._from_variable_to_descendants[parent].update(
            self._from_variable_to_descendants[child]
        )

        new_descendants_of_parent = (
            self._from_variable_to_descendants[parent] - previous_descendants_of_parent
        )

        self.propagate_new_descendants_to_ancestors(
            variable=parent, new_descendants=new_descendants_of_parent
        )

    def propagate_new_descendants_to_ancestors(
        self, variable: Variable, new_descendants: Set[Variable]
    ):
        if (
            not empty(new_descendants)
            and variable in self.from_variable_to_distribution
        ):
            distribution = self.from_variable_to_distribution[variable]
            parents = distribution.variables[1:]
            for parent in parents:
                new_descendants_of_parent = (
                    new_descendants - self._from_variable_to_descendants[parent]
                )
                self._from_variable_to_descendants[parent].update(
                    new_descendants_of_parent
                )
                self.propagate_new_descendants_to_ancestors(
                    parent, new_descendants_of_parent
                )

    # Basic methods and properties

    def make_new_variable(self, type: Type) -> Variable:
        variable_name = f"x{self.number_of_variables_generated_so_far + 1}"
        variable_maker = self.from_type_to_variable_maker.get(
            type, type
        )  # type's constructor is used as default
        new_variable = variable_maker(variable_name)
        self._queue_of_variables_without_distribution.append(new_variable)
        self._from_variable_to_descendants[new_variable] = set()
        return new_variable

    @property
    def variables_generated_so_far(self) -> Iterable[Variable]:
        return (
            list(self.from_variable_to_distribution.keys())
            + list(self._queue_of_variables_without_distribution)
            + (
                [self.child_being_processed]
                if self.child_being_processed is not None
                else []
            )
        )

    @property
    def number_of_variables_generated_so_far(self) -> int:
        return (
            len(self.from_variable_to_distribution)
            + len(self._queue_of_variables_without_distribution)
            + (1 if self.child_being_processed is not None else 0)
        )

    @property
    def number_of_variables_that_still_need_to_be_generated(self) -> int:
        return (
            self.threshold_number_of_variables_to_generate
            - self.number_of_variables_generated_so_far
        )
